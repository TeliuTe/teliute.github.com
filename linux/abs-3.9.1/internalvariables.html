<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
> <meta content="text/html; charset=UTF-8" http-equiv="content-type" /><TITLE
>内部变量</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="高级Bash脚本编程指南"
HREF="index.html"><LINK
REL="UP"
TITLE="变量重游"
HREF="variables2.html"><LINK
REL="PREVIOUS"
TITLE="变量重游"
HREF="variables2.html"><LINK
REL="NEXT"
TITLE="操作字符串"
HREF="string-manipulation.html"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#CCFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>高级Bash脚本编程指南: 一本深入学习shell脚本艺术的书籍</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="variables2.html"
ACCESSKEY="P"
>前一页</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>9. 变量重游</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="string-manipulation.html"
ACCESSKEY="N"
>下一页</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="INTERNALVARIABLES"
>9.1. 内部变量</A
></H1
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="REPLACEABLE"
><I
><A
HREF="internal.html#BUILTINREF"
>内建</A
>变量</I
></TT
></DT
><DD
><P
>这些变量将会影响bash脚本的行为.</P
></DD
><DT
><CODE
CLASS="VARNAME"
>$BASH</CODE
></DT
><DD
><P
><EM
>Bash</EM
>的二进制程序文件的路径
	      <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>bash$ </SAMP
><KBD
CLASS="USERINPUT"
>echo $BASH</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>/bin/bash</SAMP
></PRE
></FONT
></TD
></TR
></TABLE
>
	    </P
></DD
><DT
><CODE
CLASS="VARNAME"
>$BASH_ENV</CODE
></DT
><DD
><P
>这个<A
HREF="othertypesv.html#ENVREF"
>环境变量</A
>会指向一个Bash的启动文件, 
			  当一个脚本被调用的时候, 这个启动文件将会被读取. </P
></DD
><DT
><A
NAME="BASHSUBSHELLREF"
></A
><CODE
CLASS="VARNAME"
>$BASH_SUBSHELL</CODE
></DT
><DD
><P
>这个变量用来提示<A
HREF="subshells.html#SUBSHELLSREF"
>子shell</A
>的层次. 
			这是一个Bash的新特性, 直到<A
HREF="bashver3.html#BASH3REF"
>版本3</A
>的Bash才被引入近来.</P
><P
>参考<A
HREF="subshells.html#SUBSHELL"
>例子 20-1</A
>中的用法.</P
></DD
><DT
><CODE
CLASS="VARNAME"
>$BASH_VERSINFO[n]</CODE
></DT
><DD
><P
>这是一个含有6个元素的<A
HREF="arrays.html#ARRAYREF"
>数组</A
>, 
			  它包含了所安装的Bash的版本信息. 
			  这与下边的<CODE
CLASS="VARNAME"
>$BASH_VERSION</CODE
>很相像,
	    但是这个更加详细一些.</P
><P
>	  <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;# Bash version info:
  2&nbsp;
  3&nbsp;for n in 0 1 2 3 4 5
  4&nbsp;do
  5&nbsp;  echo "BASH_VERSINFO[$n] = ${BASH_VERSINFO[$n]}"
  6&nbsp;done  
  7&nbsp;
  8&nbsp;# BASH_VERSINFO[0] = 3                      # 主版本号.
  9&nbsp;# BASH_VERSINFO[1] = 00                     # 次版本号.
 10&nbsp;# BASH_VERSINFO[2] = 14                     # 补丁次数.
 11&nbsp;# BASH_VERSINFO[3] = 1                      # 编译版本.
 12&nbsp;# BASH_VERSINFO[4] = release                # 发行状态.
 13&nbsp;# BASH_VERSINFO[5] = i386-redhat-linux-gnu  # 结构体系
 14&nbsp;                                            # (与变量$MACHTYPE相同).</PRE
></FONT
></TD
></TR
></TABLE
>
	  </P
></DD
><DT
><CODE
CLASS="VARNAME"
>$BASH_VERSION</CODE
></DT
><DD
><P
>安装在系统上的Bash版本号</P
><P
>	      <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>bash$ </SAMP
><KBD
CLASS="USERINPUT"
>echo $BASH_VERSION</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>3.00.14(1)-release</SAMP
>
	      </PRE
></FONT
></TD
></TR
></TABLE
>
	    </P
><P
>	      <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>tcsh% </SAMP
><KBD
CLASS="USERINPUT"
>echo $BASH_VERSION</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>BASH_VERSION: Undefined variable.</SAMP
>
	      </PRE
></FONT
></TD
></TR
></TABLE
>
	    </P
><P
>检查$BASH_VERSION对于判断系统上到底运行的是哪个shell来说是一种非常好的方法. 
			变量<A
HREF="internalvariables.html#SHELLVARREF"
>$SHELL</A
>有时候不能够给出正确的答案. </P
></DD
><DT
><A
NAME="DIRSTACKREF"
></A
><CODE
CLASS="VARNAME"
>$DIRSTACK</CODE
></DT
><DD
><P
>在目录栈中最顶端的值.
	    (将会受到<A
HREF="internal.html#PUSHDREF"
>pushd</A
>和<A
HREF="internal.html#POPDREF"
>popd</A
>的影响)</P
><P
>这个内建变量与<A
HREF="internal.html#DIRSD"
>dirs</A
>命令相符,
	    但是<B
CLASS="COMMAND"
>dirs</B
>命令会显示目录栈的整个内容. </P
></DD
><DT
><CODE
CLASS="VARNAME"
>$EDITOR</CODE
></DT
><DD
><P
>脚本所调用的默认编辑器, 
			 通常情况下是<B
CLASS="COMMAND"
>vi</B
>或者是<B
CLASS="COMMAND"
>emacs</B
>.</P
></DD
><DT
><A
NAME="EUIDREF"
></A
><CODE
CLASS="VARNAME"
>$EUID</CODE
></DT
><DD
><P
><SPAN
CLASS="QUOTE"
>"有效"</SPAN
>用户ID</P
><P
>不管当前用户被假定成什么用户, 这个数都用来表示当前用户的标识号, 也可能使用<A
HREF="system.html#SUREF"
>su</A
>命令来达到假定的目的.</P
><DIV
CLASS="CAUTION"
><P
></P
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./images/caution.gif"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><CODE
CLASS="VARNAME"
>$EUID</CODE
>并不一定与<A
HREF="internalvariables.html#UIDREF"
>$UID</A
>相同.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><CODE
CLASS="VARNAME"
>$FUNCNAME</CODE
></DT
><DD
><P
>当前函数的名字</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;xyz23 ()
  2&nbsp;{
  3&nbsp;  echo "$FUNCNAME now executing."  # 打印: xyz23 now executing.
  4&nbsp;}
  5&nbsp;
  6&nbsp;xyz23
  7&nbsp;
  8&nbsp;echo "FUNCNAME = $FUNCNAME"        # FUNCNAME =
  9&nbsp;                                   # 超出函数的作用域就变为null值了. </PRE
></FONT
></TD
></TR
></TABLE
>
            </P
></DD
><DT
><CODE
CLASS="VARNAME"
>$GLOBIGNORE</CODE
></DT
><DD
><P
>一个文件名的模式匹配列表, 如果在<A
HREF="globbingref.html"
>通配(globbing)</A
>中匹配到的文件包含有这个列表中的某个文件, 
			  那么这个文件将被从匹配到的结果中去掉.</P
></DD
><DT
><A
NAME="GROUPSREF"
></A
><CODE
CLASS="VARNAME"
>$GROUPS</CODE
></DT
><DD
><P
>目前用户所属的组</P
><P
>这是一个当前用户的组id列表(数组), 与记录在<TT
CLASS="FILENAME"
>/etc/passwd</TT
>文件中的内容一样.
	    </P
><P
>	      <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>root# </SAMP
><KBD
CLASS="USERINPUT"
>echo $GROUPS</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>0</SAMP
>


<SAMP
CLASS="PROMPT"
>root# </SAMP
><KBD
CLASS="USERINPUT"
>echo ${GROUPS[1]}</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>1</SAMP
>


<SAMP
CLASS="PROMPT"
>root# </SAMP
><KBD
CLASS="USERINPUT"
>echo ${GROUPS[5]}</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>6</SAMP
>
	      </PRE
></FONT
></TD
></TR
></TABLE
>
	      </P
></DD
><DT
><A
NAME="HOMEDIRREF"
></A
><CODE
CLASS="VARNAME"
>$HOME</CODE
></DT
><DD
><P
>用户的home目录, 一般是<TT
CLASS="FILENAME"
>/home/username</TT
>(参见<A
HREF="parameter-substitution.html#EX6"
>例子 9-15</A
>)</P
></DD
><DT
><A
NAME="HOSTNAMEREF"
></A
><CODE
CLASS="VARNAME"
>$HOSTNAME</CODE
></DT
><DD
><P
><A
HREF="system.html#HNAMEREF"
>hostname</A
>放在一个初始化脚本中, 
	    在系统启动的时候分配一个系统名字.
	    然而, <CODE
CLASS="FUNCTION"
>gethostname()</CODE
>函数可以用来设置这个Bash内部变量<CODE
CLASS="VARNAME"
>$HOSTNAME</CODE
>.
	    参见<A
HREF="parameter-substitution.html#EX6"
>例子 9-15</A
>.</P
></DD
><DT
><CODE
CLASS="VARNAME"
>$HOSTTYPE</CODE
></DT
><DD
><P
>主机类型</P
><P
>就像<A
HREF="internalvariables.html#MACHTYPEREF"
>$MACHTYPE</A
>,
	      用来识别系统硬件.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>bash$ </SAMP
><KBD
CLASS="USERINPUT"
>echo $HOSTTYPE</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>i686</SAMP
></PRE
></FONT
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="IFSREF"
></A
><CODE
CLASS="VARNAME"
>$IFS</CODE
></DT
><DD
><P
>内部域分隔符</P
><P
>这个变量用来决定Bash在解释字符串时如何识别域, 或者单词边界.</P
><P
>$IFS默认为<A
HREF="special-chars.html#WHITESPACEREF"
>空白</A
>(空格,
	      制表符,和换行符), 但这是可以修改的, 比如,
		  在分析逗号分隔的数据文件时, 就可以设置为逗号. 
		  注意<A
HREF="internalvariables.html#APPREF"
>$*</A
>使用的是保存在<CODE
CLASS="VARNAME"
>$IFS</CODE
>中的第一个字符.  参见<A
HREF="quotingvar.html#WEIRDVARS"
>例子 5-1</A
>.</P
><P
>	      <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>bash$ </SAMP
><KBD
CLASS="USERINPUT"
>echo $IFS | cat -vte</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>$</SAMP
>
<SAMP
CLASS="COMPUTEROUTPUT"
>(Show tabs and display "$" at end-of-line.)</SAMP
>



<SAMP
CLASS="PROMPT"
>bash$ </SAMP
><KBD
CLASS="USERINPUT"
>bash -c 'set w x y z; IFS=":-;"; echo "$*"'</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>w:x:y:z</SAMP
>
<SAMP
CLASS="COMPUTEROUTPUT"
>(从字符串中读取命令, 并分配参数给位置参数.)</SAMP
>
	      </PRE
></FONT
></TD
></TR
></TABLE
>
	  </P
><DIV
CLASS="CAUTION"
><P
></P
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./images/caution.gif"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><CODE
CLASS="VARNAME"
>$IFS</CODE
>处理其他字符与处理空白字符不同. 

	  <DIV
CLASS="EXAMPLE"
><HR><A
NAME="IFSH"
></A
><P
><B
>例子 9-1. $IFS与空白字符</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# $IFS 处理空白与处理其他字符不同. 
  3&nbsp;
  4&nbsp;output_args_one_per_line()
  5&nbsp;{
  6&nbsp;  for arg
  7&nbsp;  do echo "[$arg]"
  8&nbsp;  done
  9&nbsp;}
 10&nbsp;
 11&nbsp;echo; echo "IFS=\" \""
 12&nbsp;echo "-------"
 13&nbsp;
 14&nbsp;IFS=" "
 15&nbsp;var=" a  b c   "
 16&nbsp;output_args_one_per_line $var  # output_args_one_per_line `echo " a  b c   "`
 17&nbsp;#
 18&nbsp;# [a]
 19&nbsp;# [b]
 20&nbsp;# [c]
 21&nbsp;
 22&nbsp;
 23&nbsp;echo; echo "IFS=:"
 24&nbsp;echo "-----"
 25&nbsp;
 26&nbsp;IFS=:
 27&nbsp;var=":a::b:c:::"               # 与上边一样, 但是用" "替换了":".
 28&nbsp;output_args_one_per_line $var
 29&nbsp;#
 30&nbsp;# []
 31&nbsp;# [a]
 32&nbsp;# []
 33&nbsp;# [b]
 34&nbsp;# [c]
 35&nbsp;# []
 36&nbsp;# []
 37&nbsp;# []
 38&nbsp;
 39&nbsp;# 同样的事情也会发生在awk的"FS"域中.
 40&nbsp;
 41&nbsp;# 感谢, Stephane Chazelas.
 42&nbsp;
 43&nbsp;echo
 44&nbsp;
 45&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
>

	  </P
></TD
></TR
></TABLE
></DIV
><P
>(感谢, S. C., 进行了澄清与举例.)</P
><P
>参见<A
HREF="communications.html#ISSPAMMER"
>例子 12-37</A
>, <A
HREF="loops1.html#BINGREP"
>例子 10-7</A
>, 和<A
HREF="x13628.html#MAILBOXGREP"
>例子 17-14</A
>
             都是展示如何使用<CODE
CLASS="VARNAME"
>$IFS</CODE
>的例子.</P
></DD
><DT
><CODE
CLASS="VARNAME"
>$IGNOREEOF</CODE
></DT
><DD
><P
>忽略EOF: 告诉shell在log out之前要忽略多少文件结束符(control-D). </P
></DD
><DT
><CODE
CLASS="VARNAME"
>$LC_COLLATE</CODE
></DT
><DD
><P
>常在<TT
CLASS="FILENAME"
>.bashrc</TT
>或<TT
CLASS="FILENAME"
>/etc/profile</TT
>中设置, 
			  这个变量用来控制文件名扩展和模式匹配的展开顺序.
			  如果$LC_COLLATE设置得不正确的话, 
			  <CODE
CLASS="VARNAME"
>LC_COLLATE</CODE
>会在<A
HREF="globbingref.html"
>文件名匹配(filename 
				  globbing)</A
>中产生不可预料的结果.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>在2.05以后的Bash版本中,
	    文件名匹配(filename globbing)将不在区分中括号结构中的字符范围里字符的大小写. 
	    比如, <B
CLASS="COMMAND"
>ls [A-M]*</B
>
		既能够匹配为<TT
CLASS="FILENAME"
>File1.txt</TT
>也能够匹配为<TT
CLASS="FILENAME"
>file1.txt</TT
>. 
		为了能够恢复中括号里字符的匹配行为(即区分大小写), 
	    可以设置变量<CODE
CLASS="VARNAME"
>LC_COLLATE</CODE
>为<CODE
CLASS="OPTION"
>C</CODE
>, 
		在文件<TT
CLASS="FILENAME"
>/etc/profile</TT
>或<TT
CLASS="FILENAME"
>~/.bashrc</TT
>中使用<KBD
CLASS="USERINPUT"
>export LC_COLLATE=C</KBD
>, 
		可以达到这个目的.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><CODE
CLASS="VARNAME"
>$LC_CTYPE</CODE
></DT
><DD
><P
>这个内部变量用来控制<A
HREF="globbingref.html"
>通配(globbing)</A
>和模式匹配中的字符串解释. </P
></DD
><DT
><A
NAME="LINENOREF"
></A
><CODE
CLASS="VARNAME"
>$LINENO</CODE
></DT
><DD
><P
>这个变量用来记录自身在脚本中所在的行号. 
			  这个变量只有在脚本使用这个变量的时候才有意义, 
			 并且这个变量一般用于调试目的. </P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;# *** 调试代码块开始 ***
  2&nbsp;last_cmd_arg=$_  # Save it.
  3&nbsp;
  4&nbsp;echo "At line number $LINENO, variable \"v1\" = $v1"
  5&nbsp;echo "Last command argument processed = $last_cmd_arg"
  6&nbsp;# *** 调试代码块结束 ***</PRE
></FONT
></TD
></TR
></TABLE
></P
></DD
><DT
><A
NAME="MACHTYPEREF"
></A
><CODE
CLASS="VARNAME"
>$MACHTYPE</CODE
></DT
><DD
><P
>机器类型</P
><P
>标识系统的硬件.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>bash$ </SAMP
><KBD
CLASS="USERINPUT"
>echo $MACHTYPE</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>i686</SAMP
></PRE
></FONT
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="OLDPWD"
></A
><CODE
CLASS="VARNAME"
>$OLDPWD</CODE
></DT
><DD
><P
>之前的工作目录(<SPAN
CLASS="QUOTE"
>"OLD-print-working-directory"</SPAN
>,
	    就是之前你所在的目录)</P
></DD
><DT
><CODE
CLASS="VARNAME"
>$OSTYPE</CODE
></DT
><DD
><P
>操作系统类型</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>bash$ </SAMP
><KBD
CLASS="USERINPUT"
>echo $OSTYPE</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>linux</SAMP
></PRE
></FONT
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="PATHREF"
></A
><CODE
CLASS="VARNAME"
>$PATH</CODE
></DT
><DD
><P
>可执行文件的搜索路径, 
			 一般为<TT
CLASS="FILENAME"
>/usr/bin/</TT
>, 
	      <TT
CLASS="FILENAME"
>/usr/X11R6/bin/</TT
>, 
	      <TT
CLASS="FILENAME"
>/usr/local/bin</TT
>, 等等.</P
><P
>当给出一个命令时, shell会自动生成一张哈希(hash)表,  
		  并且在这张哈希表中按照<EM
>path</EM
>变量中所列出的路径来搜索这个可执行命令.
		  路径会存储在<A
HREF="othertypesv.html#ENVREF"
>环境变量</A
>中, 
		  <CODE
CLASS="VARNAME"
>$PATH</CODE
>变量本身就一个以冒号分隔的目录列表. 
		  通常情况下, 系统都是在<TT
CLASS="FILENAME"
>/etc/profile</TT
>和<TT
CLASS="FILENAME"
>~/.bashrc</TT
>中存储<CODE
CLASS="VARNAME"
>$PATH</CODE
>的定义.
	      (参考<A
HREF="files.html"
>Appendix G</A
>).</P
><P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>bash$ </SAMP
><B
CLASS="COMMAND"
>echo $PATH</B
>
<SAMP
CLASS="COMPUTEROUTPUT"
>/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin:/sbin:/usr/sbin</SAMP
></PRE
></FONT
></TD
></TR
></TABLE
>
              </P
><P
><KBD
CLASS="USERINPUT"
>PATH=${PATH}:/opt/bin</KBD
>将会把目录<TT
CLASS="FILENAME"
>/opt/bin</TT
>附加到当前目录列表中.
			在脚本中, 这是一种把目录临时添加到$PATH中的权宜之计. 
			当这个脚本退出时, <CODE
CLASS="VARNAME"
>$PATH</CODE
>将会恢复以前的值(一个子进程, 比如说一个脚本,
			是不能够修改父进程的环境变量的, 在这里也就是不能够修改shell本身的环境变量, 
			-- 译者注: 也就是脚本所运行的这个shell). </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>当前的<SPAN
CLASS="QUOTE"
>"工作目录"</SPAN
>, 
				<TT
CLASS="FILENAME"
>./</TT
>, 通常是不会出现在<CODE
CLASS="VARNAME"
>$PATH</CODE
>中的, 
				这样做的目的是出于安全的考虑. </P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><CODE
CLASS="VARNAME"
>$PIPESTATUS</CODE
></DT
><DD
><P
>这个<A
HREF="arrays.html#ARRAYREF"
>数组</A
>变量将保存最后一个运行的<EM
>前台</EM
><A
HREF="special-chars.html#PIPEREF"
>管道</A
>的退出状态码. 
		  相当有趣的是, 这个退出状态码和最后一个命令运行的<A
HREF="exit-status.html#EXITSTATUSREF"
>退出状态码</A
>并不一定相同. </P
><P
>	      <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>bash$ </SAMP
><KBD
CLASS="USERINPUT"
>echo $PIPESTATUS</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>0</SAMP
>

<SAMP
CLASS="PROMPT"
>bash$ </SAMP
><KBD
CLASS="USERINPUT"
>ls -al | bogus_command</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>bash: bogus_command: command not found</SAMP
>
<SAMP
CLASS="PROMPT"
>bash$ </SAMP
><KBD
CLASS="USERINPUT"
>echo $PIPESTATUS</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>141</SAMP
>

<SAMP
CLASS="PROMPT"
>bash$ </SAMP
><KBD
CLASS="USERINPUT"
>ls -al | bogus_command</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>bash: bogus_command: command not found</SAMP
>
<SAMP
CLASS="PROMPT"
>bash$ </SAMP
><KBD
CLASS="USERINPUT"
>echo $?</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>127</SAMP
>
	      </PRE
></FONT
></TD
></TR
></TABLE
>
	      </P
><P
><CODE
CLASS="VARNAME"
>$PIPESTATUS</CODE
>数组的每个成员都保存了运行在管道中的相应命令的退出状态码. 
		<CODE
CLASS="VARNAME"
>$PIPESTATUS[0]</CODE
>保存管道中第一个命令的退出状态码.
		<CODE
CLASS="VARNAME"
>$PIPESTATUS[1]</CODE
>保存第二个命令的退出状态码, 依此类推. </P
><DIV
CLASS="CAUTION"
><P
></P
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./images/caution.gif"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	      <CODE
CLASS="VARNAME"
>$PIPESTATUS</CODE
>变量在一个登陆的shell中可能会包含一个不正确<SPAN
CLASS="ERRORCODE"
>0</SPAN
>值(在3.0以下版本).
              </P
><P
>	      <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>tcsh% </SAMP
><KBD
CLASS="USERINPUT"
>bash</KBD
>

<SAMP
CLASS="PROMPT"
>bash$ </SAMP
><KBD
CLASS="USERINPUT"
>who | grep nobody | sort</KBD
>
<SAMP
CLASS="PROMPT"
>bash$ </SAMP
><KBD
CLASS="USERINPUT"
>echo ${PIPESTATUS[*]}</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>0</SAMP
>
	      </PRE
></FONT
></TD
></TR
></TABLE
>
	      </P
><P
>	      如果一个脚本包含了上边的这行, 那么将会产生我们所期望的<SAMP
CLASS="COMPUTEROUTPUT"
>0 1 0</SAMP
>的输出.
              </P
><P
>	      感谢, Wayne Pollock指出这一点并提供了上边的例子. 
	      </P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>在某些上下文中, 变量<CODE
CLASS="VARNAME"
>$PIPESTATUS</CODE
>可能不会给出期望的结果. </P
><P
>	      <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>bash$ </SAMP
><KBD
CLASS="USERINPUT"
>echo $BASH_VERSION</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>3.00.14(1)-release</SAMP
>

<SAMP
CLASS="PROMPT"
>bash$ </SAMP
><KBD
CLASS="USERINPUT"
>$ ls | bogus_command | wc</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>bash: bogus_command: command not found
 0       0       0</SAMP
>

<SAMP
CLASS="PROMPT"
>bash$ </SAMP
><KBD
CLASS="USERINPUT"
>echo ${PIPESTATUS[@]}</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>141 127 0</SAMP
>
	      </PRE
></FONT
></TD
></TR
></TABLE
>
	      </P
><P
>Chet Ramey把上边输出不正确的原因归咎于<A
HREF="basic.html#LSREF"
>ls</A
>的行为. 
			 因为如果把<EM
>ls</EM
>的结果放到管道上, 并且这个输出并没有被读取, 
			 那么SIGPIPE将会杀掉它, 同时<A
HREF="exit-status.html#EXITSTATUSREF"
>退出状态码</A
>变为<SPAN
CLASS="RETURNVALUE"
>141</SPAN
>. 
			 而不是我们所期望的<SPAN
CLASS="RETURNVALUE"
>0</SPAN
>. 
		这种情况也会发生在<A
HREF="textproc.html#TRREF"
>tr</A
>命令中.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><CODE
CLASS="VARNAME"
>$PIPESTATUS</CODE
>是一个<SPAN
CLASS="QUOTE"
>"不稳定"</SPAN
>变量. 
				这个变量需要在任何命令干涉之前, 并在管道询问之后立刻被查询. </P
><P
>	      <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>bash$ </SAMP
><KBD
CLASS="USERINPUT"
>$ ls | bogus_command | wc</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>bash: bogus_command: command not found
 0       0       0</SAMP
>

<SAMP
CLASS="PROMPT"
>bash$ </SAMP
><KBD
CLASS="USERINPUT"
>echo ${PIPESTATUS[@]}</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>0 127 0</SAMP
>

<SAMP
CLASS="PROMPT"
>bash$ </SAMP
><KBD
CLASS="USERINPUT"
>echo ${PIPESTATUS[@]}</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>0</SAMP
>
	      </PRE
></FONT
></TD
></TR
></TABLE
>
	      </P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="PPIDREF"
></A
><CODE
CLASS="VARNAME"
>$PPID</CODE
></DT
><DD
><P
></P
><P
>进程的<CODE
CLASS="VARNAME"
>$PPID</CODE
>就是这个进程的父进程的进程ID(<CODE
CLASS="VARNAME"
>pid</CODE
>).

	      <A
NAME="AEN4091"
HREF="#FTN.AEN4091"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
>
	      </P
><P
>和<A
HREF="system.html#PIDOFREF"
>pidof</A
>命令比较一下.</P
></DD
><DT
><CODE
CLASS="VARNAME"
>$PROMPT_COMMAND</CODE
></DT
><DD
><P
>这个变量保存了在主提示符<CODE
CLASS="VARNAME"
>$PS1</CODE
>显示之前需要执行的命令. </P
></DD
><DT
><A
NAME="PS1REF"
></A
><CODE
CLASS="VARNAME"
>$PS1</CODE
></DT
><DD
><P
>这是主提示符, 可以在命令行中见到它. </P
></DD
><DT
><CODE
CLASS="VARNAME"
>$PS2</CODE
></DT
><DD
><P
><A
NAME="SECPROMPTREF"
></A
></P
><P
>第二提示符, 当你需要额外输入的时候, 你就会看到它. 默认显示<SPAN
CLASS="QUOTE"
>"&#62;"</SPAN
>.</P
></DD
><DT
><CODE
CLASS="VARNAME"
>$PS3</CODE
></DT
><DD
><P
>第三提示符, 它在一个<A
HREF="testbranch.html#SELECTREF"
>select</A
>循环中显示(参见<A
HREF="testbranch.html#EX31"
>例子 10-29</A
>).</P
></DD
><DT
><CODE
CLASS="VARNAME"
>$PS4</CODE
></DT
><DD
><P
>第四提示符, 当你使用<SPAN
CLASS="TOKEN"
>-x</SPAN
><A
HREF="options.html#OPTIONSREF"
>选项</A
>来调用脚本时,
	    这个提示符会出现在每行输出的开头. 默认显示<SPAN
CLASS="QUOTE"
>"+"</SPAN
>.</P
></DD
><DT
><A
NAME="PWDREF"
></A
><CODE
CLASS="VARNAME"
>$PWD</CODE
></DT
><DD
><P
>工作目录(你当前所在的目录)</P
><P
>这与内建命令<A
HREF="internal.html#PWD2REF"
>pwd</A
>作用相同. </P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;
  3&nbsp;E_WRONG_DIRECTORY=73
  4&nbsp;
  5&nbsp;clear # 清屏.
  6&nbsp;
  7&nbsp;TargetDirectory=/home/bozo/projects/GreatAmericanNovel
  8&nbsp;
  9&nbsp;cd $TargetDirectory
 10&nbsp;echo "Deleting stale files in $TargetDirectory."
 11&nbsp;
 12&nbsp;if [ "$PWD" != "$TargetDirectory" ]
 13&nbsp;then    # 防止偶然删错目录.
 14&nbsp;  echo "Wrong directory!"
 15&nbsp;  echo "In $PWD, rather than $TargetDirectory!"
 16&nbsp;  echo "Bailing out!"
 17&nbsp;  exit $E_WRONG_DIRECTORY
 18&nbsp;fi  
 19&nbsp;
 20&nbsp;rm -rf *
 21&nbsp;rm .[A-Za-z0-9]*    # 删除点文件(译者注: 隐藏文件). 
 22&nbsp;# rm -f .[^.]* ..?*   为了删除以多个点开头的文件. 
 23&nbsp;# (shopt -s dotglob; rm -f *)   也可以.
 24&nbsp;# 感谢, S.C. 指出这点.
 25&nbsp;
 26&nbsp;# 文件名可以包含ascii中0 - 255范围内的所有字符, 除了"/".
 27&nbsp;# 删除以各种诡异字符开头的文件将会作为一个练习留给大家.
 28&nbsp;
 29&nbsp;# 如果必要的话, 这里预留给其他操作.
 30&nbsp;
 31&nbsp;echo
 32&nbsp;echo "Done."
 33&nbsp;echo "Old files deleted in $TargetDirectory."
 34&nbsp;echo
 35&nbsp;
 36&nbsp;
 37&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
></P
></DD
><DT
><A
NAME="REPLYREF"
></A
><CODE
CLASS="VARNAME"
>$REPLY</CODE
></DT
><DD
><P
>当没有参数变量提供给<A
HREF="internal.html#READREF"
>read</A
>命令的时候, 
			  这个变量会作为默认变量提供给read命令. 
			  也可以用于<A
HREF="testbranch.html#SELECTREF"
>select</A
>菜单,
	    但是只提供所选择变量的编号, 而不是变量本身的值. </P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# reply.sh
  3&nbsp;
  4&nbsp;# REPLY是提供给'read'命令的默认变量.
  5&nbsp;
  6&nbsp;echo
  7&nbsp;echo -n "What is your favorite vegetable? "
  8&nbsp;read
  9&nbsp;
 10&nbsp;echo "Your favorite vegetable is $REPLY."
 11&nbsp;#  当且仅当没有变量提供给"read"命令时, 
 12&nbsp;#+ REPLY才保存最后一个"read"命令读入的值.
 13&nbsp;
 14&nbsp;echo
 15&nbsp;echo -n "What is your favorite fruit? "
 16&nbsp;read fruit
 17&nbsp;echo "Your favorite fruit is $fruit."
 18&nbsp;echo "but..."
 19&nbsp;echo "Value of \$REPLY is still $REPLY."
 20&nbsp;#  $REPLY还是保存着上一个read命令的值,
 21&nbsp;#+ 因为变量$fruit被传入到了这个新的"read"命令中.
 22&nbsp;
 23&nbsp;echo
 24&nbsp;
 25&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
></P
></DD
><DT
><CODE
CLASS="VARNAME"
>$SECONDS</CODE
></DT
><DD
><P
>这个脚本已经运行的时间(以秒为单位).</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;
  3&nbsp;TIME_LIMIT=10
  4&nbsp;INTERVAL=1
  5&nbsp;
  6&nbsp;echo
  7&nbsp;echo "Hit Control-C to exit before $TIME_LIMIT seconds."
  8&nbsp;echo
  9&nbsp;
 10&nbsp;while [ "$SECONDS" -le "$TIME_LIMIT" ]
 11&nbsp;do
 12&nbsp;  if [ "$SECONDS" -eq 1 ]
 13&nbsp;  then
 14&nbsp;    units=second
 15&nbsp;  else  
 16&nbsp;    units=seconds
 17&nbsp;  fi
 18&nbsp;
 19&nbsp;  echo "This script has been running $SECONDS $units."
 20&nbsp;  #  在一台比较慢或者是附载过大的机器上, 
 21&nbsp;  #+ 在单次循环中, 脚本可能会忽略计数. 
 22&nbsp;  sleep $INTERVAL
 23&nbsp;done
 24&nbsp;
 25&nbsp;echo -e "\a"  # Beep!(哔哔声!)
 26&nbsp;
 27&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
></P
></DD
><DT
><CODE
CLASS="VARNAME"
>$SHELLOPTS</CODE
></DT
><DD
><P
>shell中已经激活的<A
HREF="options.html#OPTIONSREF"
>选项</A
>的列表, 这是一个只读变量.
	      <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>bash$ </SAMP
><KBD
CLASS="USERINPUT"
>echo $SHELLOPTS</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>braceexpand:hashall:histexpand:monitor:history:interactive-comments:emacs</SAMP
>
	      </PRE
></FONT
></TD
></TR
></TABLE
>
	    </P
></DD
><DT
><CODE
CLASS="VARNAME"
>$SHLVL</CODE
></DT
><DD
><P
>Shell级别, 就是Bash被嵌套的深度. 
			  如果是在命令行中, 那么$SHLVL为1, 如果在脚本中那么$SHLVL为2. </P
></DD
><DT
><CODE
CLASS="VARNAME"
>$TMOUT</CODE
></DT
><DD
><P
>如果<TT
CLASS="REPLACEABLE"
><I
>$TMOUT</I
></TT
>环境变量被设置为非零值<EM
>time</EM
>的话, 
			  那么经过<EM
>time</EM
>秒后, shell提示符将会超时. 
			  这将会导致登出(logout).</P
><P
>在2.05b版本的Bash中, <TT
CLASS="REPLACEABLE"
><I
>$TMOUT</I
></TT
>变量与命令<A
HREF="internal.html#READREF"
>read</A
>可以在脚本中结合使用.</P
><P
>	  <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;# 只能够在Bash脚本中使用, 必须使用2.05b或之后版本的Bash.
  2&nbsp;
  3&nbsp;TMOUT=3    # 提示输入时间为3秒.
  4&nbsp;
  5&nbsp;echo "What is your favorite song?"
  6&nbsp;echo "Quickly now, you only have $TMOUT seconds to answer!"
  7&nbsp;read song
  8&nbsp;
  9&nbsp;if [ -z "$song" ]
 10&nbsp;then
 11&nbsp;  song="(no answer)"
 12&nbsp;  # 默认响应.
 13&nbsp;fi
 14&nbsp;
 15&nbsp;echo "Your favorite song is $song."</PRE
></FONT
></TD
></TR
></TABLE
>
	  </P
><P
>还有更加复杂的办法可以在脚本中实现定时输入.
		一种办法就是建立一个定式循环, 当超时的时候给脚本发个信号. 
	    不过这也需要有一个信号处理例程能够捕捉(参见<A
HREF="debugging.html#EX76"
>例子 29-5</A
>)由定时循环所产生的中断. (哇欧!).</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="TMDIN"
></A
><P
><B
>例子 9-2. 定时输入</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# timed-input.sh
  3&nbsp;
  4&nbsp;# TMOUT=3    在新一些的Bash版本上也能运行的很好.
  5&nbsp;
  6&nbsp;
  7&nbsp;TIMELIMIT=3  # 这个例子中设置的是3秒. 也可以设置为其他的时间值.
  8&nbsp;
  9&nbsp;PrintAnswer()
 10&nbsp;{
 11&nbsp;  if [ "$answer" = TIMEOUT ]
 12&nbsp;  then
 13&nbsp;    echo $answer
 14&nbsp;  else       # 别和上边的例子弄混了.
 15&nbsp;    echo "Your favorite veggie is $answer"
 16&nbsp;    kill $!  # 不再需要后台运行的TimerOn函数了, kill了吧.
 17&nbsp;             # $! 变量是上一个在后台运行的作业的PID.
 18&nbsp;  fi
 19&nbsp;
 20&nbsp;}  
 21&nbsp;
 22&nbsp;
 23&nbsp;
 24&nbsp;TimerOn()
 25&nbsp;{
 26&nbsp;  sleep $TIMELIMIT &#38;&#38; kill -s 14 $$ &#38;
 27&nbsp;  # 等待3秒, 然后给脚本发送一个信号.
 28&nbsp;}  
 29&nbsp;
 30&nbsp;Int14Vector()
 31&nbsp;{
 32&nbsp;  answer="TIMEOUT"
 33&nbsp;  PrintAnswer
 34&nbsp;  exit 14
 35&nbsp;}  
 36&nbsp;
 37&nbsp;trap Int14Vector 14   # 定时中断(14)会暗中给定时间限制. 
 38&nbsp;
 39&nbsp;echo "What is your favorite vegetable "
 40&nbsp;TimerOn
 41&nbsp;read answer
 42&nbsp;PrintAnswer
 43&nbsp;
 44&nbsp;
 45&nbsp;#  无可否认, 这是一个定时输入的复杂实现,
 46&nbsp;#+ 然而"read"命令的"-t"选项可以简化这个任务. 
 47&nbsp;#  参考后边的"t-out.sh".
 48&nbsp;
 49&nbsp;#  如果你需要一个真正优雅的写法...
 50&nbsp;#+ 建议你使用C或C++来重写这个应用,
 51&nbsp;#+ 你可以使用合适的函数库, 比如'alarm'和'setitimer'来完成这个任务.
 52&nbsp;
 53&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><P
>另一种选择是使用<A
HREF="system.html#STTYREF"
>stty</A
>.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="TIMEOUT"
></A
><P
><B
>例子 9-3. 再来一个, 定时输入</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# timeout.sh
  3&nbsp;
  4&nbsp;#  由Stephane Chazelas所编写,
  5&nbsp;#+ 本书作者做了一些修改.
  6&nbsp;
  7&nbsp;INTERVAL=5                # 超时间隔
  8&nbsp;
  9&nbsp;timedout_read() {
 10&nbsp;  timeout=$1
 11&nbsp;  varname=$2
 12&nbsp;  old_tty_settings=`stty -g`
 13&nbsp;  stty -icanon min 0 time ${timeout}0
 14&nbsp;  eval read $varname      # 或者仅仅读取$varname变量
 15&nbsp;  stty "$old_tty_settings"
 16&nbsp;  # 参考"stty"的man页.
 17&nbsp;}
 18&nbsp;
 19&nbsp;echo; echo -n "What's your name? Quick! "
 20&nbsp;timedout_read $INTERVAL your_name
 21&nbsp;
 22&nbsp;#  这种方法可能并不是在每种终端类型上都可以正常使用的.
 23&nbsp;#  最大的超时时间依赖于具体的中断类型.
 24&nbsp;#+ (通常是25.5秒).
 25&nbsp;
 26&nbsp;echo
 27&nbsp;
 28&nbsp;if [ ! -z "$your_name" ]  # 如果在超时之前名字被键入...
 29&nbsp;then
 30&nbsp;  echo "Your name is $your_name."
 31&nbsp;else
 32&nbsp;  echo "Timed out."
 33&nbsp;fi
 34&nbsp;
 35&nbsp;echo
 36&nbsp;
 37&nbsp;# 这个脚本的行为可能与脚本"timed-input.sh"的行为有些不同.
 38&nbsp;# 每次按键, 计时器都会重置(译者注: 就是从0开始).
 39&nbsp;
 40&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><P
>可能最简单的办法就是使用<CODE
CLASS="OPTION"
>-t</CODE
>选项来<A
HREF="internal.html#READREF"
>read</A
>了.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="TOUT"
></A
><P
><B
>例子 9-4. 定时<B
CLASS="COMMAND"
>read</B
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# t-out.sh
  3&nbsp;# 从"syngin seven"的建议中得到的灵感 (感谢).
  4&nbsp;
  5&nbsp;
  6&nbsp;TIMELIMIT=4         # 4秒
  7&nbsp;
  8&nbsp;read -t $TIMELIMIT variable &#60;&#38;1
  9&nbsp;#                           ^^^
 10&nbsp;#  在这个例子中, 对于Bash 1.x和2.x就需要"&#60;&#38;1"了,
 11&nbsp;#  但是Bash 3.x就不需要.
 12&nbsp;
 13&nbsp;echo
 14&nbsp;
 15&nbsp;if [ -z "$variable" ]  # 值为null?
 16&nbsp;then
 17&nbsp;  echo "Timed out, variable still unset."
 18&nbsp;else  
 19&nbsp;  echo "variable = $variable"
 20&nbsp;fi  
 21&nbsp;
 22&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
></DD
><DT
><A
NAME="UIDREF"
></A
><CODE
CLASS="VARNAME"
>$UID</CODE
></DT
><DD
><P
>用户ID号</P
><P
>当前用户的用户标识号, 记录在<TT
CLASS="FILENAME"
>/etc/passwd</TT
>文件中
	    </P
><P
>这是当前用户的真实id, 即使只是通过使用<A
HREF="system.html#SUREF"
>su</A
>命令来临时改变为另一个用户标识, 这个id也不会被改变.
	      <CODE
CLASS="VARNAME"
>$UID</CODE
>是一个只读变量, 不能在命令行或者脚本中修改它, 
	      并且和<A
HREF="system.html#IDREF"
>id</A
>内建命令很相像.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="AMIROOT"
></A
><P
><B
>例子 9-5. 我是root么?</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# am-i-root.sh:   我是不是root用户?
  3&nbsp;
  4&nbsp;ROOT_UID=0   # Root的$UID为0.
  5&nbsp;
  6&nbsp;if [ "$UID" -eq "$ROOT_UID" ]  # 只有真正的"root"才能经受得住考验?
  7&nbsp;then
  8&nbsp;  echo "You are root."
  9&nbsp;else
 10&nbsp;  echo "You are just an ordinary user (but mom loves you just the same)."
 11&nbsp;fi
 12&nbsp;
 13&nbsp;exit 0
 14&nbsp;
 15&nbsp;
 16&nbsp;# ============================================= #
 17&nbsp;# 下边的代码不会执行, 因为脚本在上边已经退出了.
 18&nbsp;
 19&nbsp;# 下边是另外一种判断root用户的方法:
 20&nbsp;
 21&nbsp;ROOTUSER_NAME=root
 22&nbsp;
 23&nbsp;username=`id -nu`              # 或者...   username=`whoami`
 24&nbsp;if [ "$username" = "$ROOTUSER_NAME" ]
 25&nbsp;then
 26&nbsp;  echo "Rooty, toot, toot. You are root."
 27&nbsp;else
 28&nbsp;  echo "You are just a regular fella."
 29&nbsp;fi</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><P
>也请参考一下<A
HREF="sha-bang.html#EX2"
>例子 2-3</A
>.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>变量<CODE
CLASS="VARNAME"
>$ENV</CODE
>,
	  <CODE
CLASS="VARNAME"
>$LOGNAME</CODE
>, <CODE
CLASS="VARNAME"
>$MAIL</CODE
>,
	  <CODE
CLASS="VARNAME"
>$TERM</CODE
>, <CODE
CLASS="VARNAME"
>$USER</CODE
>, 
	  和<CODE
CLASS="VARNAME"
>$USERNAME</CODE
>都<EM
>不是</EM
>Bash的<A
HREF="internal.html#BUILTINREF"
>内建</A
>变量. 
	  然而这些变量经常在Bash的<A
HREF="files.html#FILESREF1"
>启动文件</A
>中被当作<A
HREF="othertypesv.html#ENVREF"
>环境变量</A
>来设置. 
	  <A
NAME="SHELLVARREF"
></A
><CODE
CLASS="VARNAME"
>$SHELL</CODE
>是用户登陆shell的名字,
	  它可以在<TT
CLASS="FILENAME"
>/etc/passwd</TT
>中设置, 或者也可以在<SPAN
CLASS="QUOTE"
>"init"</SPAN
>脚本中设置,
	  并且它也不是Bash内建的.</P
><P
>	      <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>tcsh% </SAMP
><KBD
CLASS="USERINPUT"
>echo $LOGNAME</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>bozo</SAMP
>
<SAMP
CLASS="PROMPT"
>tcsh% </SAMP
><KBD
CLASS="USERINPUT"
>echo $SHELL</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>/bin/tcsh</SAMP
>
<SAMP
CLASS="PROMPT"
>tcsh% </SAMP
><KBD
CLASS="USERINPUT"
>echo $TERM</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>rxvt</SAMP
>

<SAMP
CLASS="PROMPT"
>bash$ </SAMP
><KBD
CLASS="USERINPUT"
>echo $LOGNAME</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>bozo</SAMP
>
<SAMP
CLASS="PROMPT"
>bash$ </SAMP
><KBD
CLASS="USERINPUT"
>echo $SHELL</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>/bin/tcsh</SAMP
>
<SAMP
CLASS="PROMPT"
>bash$ </SAMP
><KBD
CLASS="USERINPUT"
>echo $TERM</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>rxvt</SAMP
>
	      </PRE
></FONT
></TD
></TR
></TABLE
>
	      </P
></TD
></TR
></TABLE
></DIV
></DD
></DL
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><P
><B
>位置参数</B
></P
><DL
><DT
><A
NAME="POSPARAMREF"
></A
><CODE
CLASS="VARNAME"
>$0</CODE
>, <CODE
CLASS="VARNAME"
>$1</CODE
>,
	  <CODE
CLASS="VARNAME"
>$2</CODE
>, 等等.</DT
><DD
><P
>位置参数, 从命令行传递到脚本, 或者传递给函数, 
			  或者<A
HREF="internal.html#SETREF"
>set</A
>给变量(参见<A
HREF="othertypesv.html#EX17"
>例子 4-5</A
>和<A
HREF="internal.html#EX34"
>例子 11-15</A
>)</P
></DD
><DT
><CODE
CLASS="VARNAME"
>$#</CODE
></DT
><DD
><P
>命令行参数
		<A
NAME="AEN4390"
HREF="#FTN.AEN4390"
><SPAN
CLASS="footnote"
>[2]</SPAN
></A
>
	    或者位置参数的个数(参见<A
HREF="wrapper.html#EX4"
>例子 33-2</A
>)</P
></DD
><DT
><A
NAME="APPREF"
></A
><CODE
CLASS="VARNAME"
>$*</CODE
></DT
><DD
><P
>所有的位置参数都被看作为一个单词.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><SPAN
CLASS="QUOTE"
>"<CODE
CLASS="VARNAME"
>$*</CODE
>"</SPAN
>必须被引用起来.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><CODE
CLASS="VARNAME"
>$@</CODE
></DT
><DD
><P
>与<SPAN
CLASS="TOKEN"
>$*</SPAN
>相同, 但是每个参数都是一个独立的引用字符串, 
		  这就意味着, 参数是被完整传递的, 并没有被解释或扩展. 
		  这也意味着, 参数列表中每个参数都被看作为单独的单词.
	      </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>当然, <SPAN
CLASS="QUOTE"
>"<CODE
CLASS="VARNAME"
>$@</CODE
>"</SPAN
>应该被引用起来.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="ARGLIST"
></A
><P
><B
>例子 9-6. <B
CLASS="COMMAND"
>arglist</B
>: 通过$*和$@列出所有的参数</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# arglist.sh
  3&nbsp;# 多使用几个参数来调用这个脚本, 比如"one two three".
  4&nbsp;
  5&nbsp;E_BADARGS=65
  6&nbsp;
  7&nbsp;if [ ! -n "$1" ]
  8&nbsp;then
  9&nbsp;  echo "Usage: `basename $0` argument1 argument2 etc."
 10&nbsp;  exit $E_BADARGS
 11&nbsp;fi  
 12&nbsp;
 13&nbsp;echo
 14&nbsp;
 15&nbsp;index=1          # 起始计数.
 16&nbsp;
 17&nbsp;echo "Listing args with \"\$*\":"
 18&nbsp;for arg in "$*"  # 如果"$*"不被""引用,那么将不能正常地工作.
 19&nbsp;do
 20&nbsp;  echo "Arg #$index = $arg"
 21&nbsp;  let "index+=1"
 22&nbsp;done             # $* 将所有的参数看成一个单词.
 23&nbsp;echo "Entire arg list seen as single word."
 24&nbsp;
 25&nbsp;echo
 26&nbsp;
 27&nbsp;index=1          # 重置计数(译者注: 从1开始).
 28&nbsp;                 # 如果你写这句会发生什么?
 29&nbsp;
 30&nbsp;echo "Listing args with \"\$@\":"
 31&nbsp;for arg in "$@"
 32&nbsp;do
 33&nbsp;  echo "Arg #$index = $arg"
 34&nbsp;  let "index+=1"
 35&nbsp;done             # $@ 把每个参数都看成是单独的单词.
 36&nbsp;echo "Arg list seen as separate words."
 37&nbsp;
 38&nbsp;echo
 39&nbsp;
 40&nbsp;index=1          # 重置计数(译者注: 从1开始).
 41&nbsp;
 42&nbsp;echo "Listing args with \$* (unquoted):"
 43&nbsp;for arg in $*
 44&nbsp;do
 45&nbsp;  echo "Arg #$index = $arg"
 46&nbsp;  let "index+=1"
 47&nbsp;done             # 未引用的$*将会把参数看成单独的单词. 
 48&nbsp;echo "Arg list seen as separate words."
 49&nbsp;
 50&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><P
><B
CLASS="COMMAND"
>shift</B
>命令执行以后, 
	      <CODE
CLASS="VARNAME"
>$@</CODE
>将会保存命令行中剩余的参数,  
	      但是没有之前的<CODE
CLASS="VARNAME"
>$1</CODE
>,
	      因为被丢弃了.
	        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;# 使用 ./scriptname 1 2 3 4 5 来调用这个脚本
  3&nbsp;
  4&nbsp;echo "$@"    # 1 2 3 4 5
  5&nbsp;shift
  6&nbsp;echo "$@"    # 2 3 4 5
  7&nbsp;shift
  8&nbsp;echo "$@"    # 3 4 5
  9&nbsp;
 10&nbsp;# 每次"shift"都会丢弃$1.
 11&nbsp;# "$@" 将包含剩下的参数. </PRE
></FONT
></TD
></TR
></TABLE
>
            </P
><P
><CODE
CLASS="VARNAME"
>$@</CODE
>也可以作为工具使用, 用来过滤传递给脚本的输入. 
			<B
CLASS="COMMAND"
>cat "$@"</B
>结构既可以接受从<TT
CLASS="FILENAME"
>stdin</TT
>传递给脚本的输入, 
	      也可以接受从参数中指定的文件中传递给脚本的输入. 参见<A
HREF="textproc.html#ROT13"
>例子 12-21</A
>和<A
HREF="textproc.html#CRYPTOQUOTE"
>例子 12-22</A
> .</P
><DIV
CLASS="CAUTION"
><P
></P
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./images/caution.gif"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><CODE
CLASS="VARNAME"
>$*</CODE
>和<CODE
CLASS="VARNAME"
>$@</CODE
>中的参数有时候会表现出不一致而且令人迷惑的行为, 
	      这都依赖于<A
HREF="internalvariables.html#IFSREF"
>$IFS</A
>的设置. </P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="INCOMPAT"
></A
><P
><B
>例子 9-7. <CODE
CLASS="VARNAME"
>$*</CODE
>和<CODE
CLASS="VARNAME"
>$@</CODE
>的不一致的行为</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;
  3&nbsp;#  内部Bash变量"$*"和"$@"的古怪行为,
  4&nbsp;#+ 都依赖于它们是否被双引号引用起来.
  5&nbsp;#  单词拆分与换行的不一致的处理.
  6&nbsp;
  7&nbsp;
  8&nbsp;set -- "First one" "second" "third:one" "" "Fifth: :one"
  9&nbsp;# 设置这个脚本的参数, $1, $2, 等等.
 10&nbsp;
 11&nbsp;echo
 12&nbsp;
 13&nbsp;echo 'IFS unchanged, using "$*"'
 14&nbsp;c=0
 15&nbsp;for i in "$*"               # 引用起来
 16&nbsp;do echo "$((c+=1)): [$i]"   # 这行在下边每个例子中都一样.
 17&nbsp;                            # 打印参数.
 18&nbsp;done
 19&nbsp;echo ---
 20&nbsp;
 21&nbsp;echo 'IFS unchanged, using $*'
 22&nbsp;c=0
 23&nbsp;for i in $*                 # 未引用
 24&nbsp;do echo "$((c+=1)): [$i]"
 25&nbsp;done
 26&nbsp;echo ---
 27&nbsp;
 28&nbsp;echo 'IFS unchanged, using "$@"'
 29&nbsp;c=0
 30&nbsp;for i in "$@"
 31&nbsp;do echo "$((c+=1)): [$i]"
 32&nbsp;done
 33&nbsp;echo ---
 34&nbsp;
 35&nbsp;echo 'IFS unchanged, using $@'
 36&nbsp;c=0
 37&nbsp;for i in $@
 38&nbsp;do echo "$((c+=1)): [$i]"
 39&nbsp;done
 40&nbsp;echo ---
 41&nbsp;
 42&nbsp;IFS=:
 43&nbsp;echo 'IFS=":", using "$*"'
 44&nbsp;c=0
 45&nbsp;for i in "$*"
 46&nbsp;do echo "$((c+=1)): [$i]"
 47&nbsp;done
 48&nbsp;echo ---
 49&nbsp;
 50&nbsp;echo 'IFS=":", using $*'
 51&nbsp;c=0
 52&nbsp;for i in $*
 53&nbsp;do echo "$((c+=1)): [$i]"
 54&nbsp;done
 55&nbsp;echo ---
 56&nbsp;
 57&nbsp;var=$*
 58&nbsp;echo 'IFS=":", using "$var" (var=$*)'
 59&nbsp;c=0
 60&nbsp;for i in "$var"
 61&nbsp;do echo "$((c+=1)): [$i]"
 62&nbsp;done
 63&nbsp;echo ---
 64&nbsp;
 65&nbsp;echo 'IFS=":", using $var (var=$*)'
 66&nbsp;c=0
 67&nbsp;for i in $var
 68&nbsp;do echo "$((c+=1)): [$i]"
 69&nbsp;done
 70&nbsp;echo ---
 71&nbsp;
 72&nbsp;var="$*"
 73&nbsp;echo 'IFS=":", using $var (var="$*")'
 74&nbsp;c=0
 75&nbsp;for i in $var
 76&nbsp;do echo "$((c+=1)): [$i]"
 77&nbsp;done
 78&nbsp;echo ---
 79&nbsp;
 80&nbsp;echo 'IFS=":", using "$var" (var="$*")'
 81&nbsp;c=0
 82&nbsp;for i in "$var"
 83&nbsp;do echo "$((c+=1)): [$i]"
 84&nbsp;done
 85&nbsp;echo ---
 86&nbsp;
 87&nbsp;echo 'IFS=":", using "$@"'
 88&nbsp;c=0
 89&nbsp;for i in "$@"
 90&nbsp;do echo "$((c+=1)): [$i]"
 91&nbsp;done
 92&nbsp;echo ---
 93&nbsp;
 94&nbsp;echo 'IFS=":", using $@'
 95&nbsp;c=0
 96&nbsp;for i in $@
 97&nbsp;do echo "$((c+=1)): [$i]"
 98&nbsp;done
 99&nbsp;echo ---
100&nbsp;
101&nbsp;var=$@
102&nbsp;echo 'IFS=":", using $var (var=$@)'
103&nbsp;c=0
104&nbsp;for i in $var
105&nbsp;do echo "$((c+=1)): [$i]"
106&nbsp;done
107&nbsp;echo ---
108&nbsp;
109&nbsp;echo 'IFS=":", using "$var" (var=$@)'
110&nbsp;c=0
111&nbsp;for i in "$var"
112&nbsp;do echo "$((c+=1)): [$i]"
113&nbsp;done
114&nbsp;echo ---
115&nbsp;
116&nbsp;var="$@"
117&nbsp;echo 'IFS=":", using "$var" (var="$@")'
118&nbsp;c=0
119&nbsp;for i in "$var"
120&nbsp;do echo "$((c+=1)): [$i]"
121&nbsp;done
122&nbsp;echo ---
123&nbsp;
124&nbsp;echo 'IFS=":", using $var (var="$@")'
125&nbsp;c=0
126&nbsp;for i in $var
127&nbsp;do echo "$((c+=1)): [$i]"
128&nbsp;done
129&nbsp;
130&nbsp;echo
131&nbsp;
132&nbsp;# 使用ksh或者zsh -y来试试这个脚本.
133&nbsp;
134&nbsp;exit 0
135&nbsp;
136&nbsp;# 这个例子脚本是由Stephane Chazelas所编写,
137&nbsp;# 并且本书作者做了轻微改动.</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><B
CLASS="COMMAND"
>$@</B
>与<B
CLASS="COMMAND"
>$*</B
>中的参数只有在被双引号引用起来的时候才会不同. </P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="IFSEMPTY"
></A
><P
><B
>例子 9-8. 当<CODE
CLASS="VARNAME"
>$IFS</CODE
>为空时的<CODE
CLASS="VARNAME"
>$*</CODE
>和<CODE
CLASS="VARNAME"
>$@</CODE
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;
  3&nbsp;#  如果$IFS被设置, 但其值为空,
  4&nbsp;#+ 那么"$*"和"$@"将不会像期望的那样显示位置参数. 
  5&nbsp;
  6&nbsp;mecho ()       # 打印位置参数.
  7&nbsp;{
  8&nbsp;echo "$1,$2,$3";
  9&nbsp;}
 10&nbsp;
 11&nbsp;
 12&nbsp;IFS=""         # 设置了, 但值为空.
 13&nbsp;set a b c      # 位置参数.
 14&nbsp;
 15&nbsp;mecho "$*"     # abc,,
 16&nbsp;mecho $*       # a,b,c
 17&nbsp;
 18&nbsp;mecho $@       # a,b,c
 19&nbsp;mecho "$@"     # a,b,c
 20&nbsp;
 21&nbsp;#  当$IFS值为空时, $*和$@的行为依赖于
 22&nbsp;#+ 正在运行的Bash或者sh的版本.
 23&nbsp;#  因此在脚本中使用这种"特性"是不明智的.
 24&nbsp;
 25&nbsp;
 26&nbsp;# 感谢, Stephane Chazelas.
 27&nbsp;
 28&nbsp;exit 0</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
></DD
></DL
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><P
><B
>其他的特殊参数</B
></P
><DL
><DT
><A
NAME="FLPREF"
></A
><CODE
CLASS="VARNAME"
>$-</CODE
></DT
><DD
><P
>传递给脚本的标记(使用<A
HREF="internal.html#SETREF"
>set</A
>命令). 参见<A
HREF="internal.html#EX34"
>例子 11-15</A
>.</P
><DIV
CLASS="CAUTION"
><P
></P
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./images/caution.gif"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>这本来是<EM
>ksh</EM
>的结构, 后来被引进到Bash中, 但是不幸的是, 
				看起来它不能够可靠的用在Bash脚本中. 一种可能的用法是让一个脚本<A
HREF="intandnonint.html#IITEST"
>测试自身是不是可交互的</A
>. </P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><CODE
CLASS="VARNAME"
>$!</CODE
></DT
><DD
><P
>运行在后台的最后一个作业的PID(进程ID)</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;LOG=$0.log
  2&nbsp;
  3&nbsp;COMMAND1="sleep 100"
  4&nbsp;
  5&nbsp;echo "Logging PIDs background commands for script: $0" &#62;&#62; "$LOG"
  6&nbsp;# 所以它们是可以被监控的, 并且可以在必要的时候kill掉它们.
  7&nbsp;echo &#62;&#62; "$LOG"
  8&nbsp;
  9&nbsp;# 记录命令.
 10&nbsp;
 11&nbsp;echo -n "PID of \"$COMMAND1\":  " &#62;&#62; "$LOG"
 12&nbsp;${COMMAND1} &#38;
 13&nbsp;echo $! &#62;&#62; "$LOG"
 14&nbsp;# "sleep 100"的PID:  1506
 15&nbsp;
 16&nbsp;# 感谢, Jacques Lederer, 对此的建议.</PRE
></FONT
></TD
></TR
></TABLE
>
            </P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;possibly_hanging_job &#38; { sleep ${TIMEOUT}; eval 'kill -9 $!' &#38;&#62; /dev/null; }
  2&nbsp;# 强制结束一个出错程序.
  3&nbsp;# 很有用, 比如用在init脚本中.
  4&nbsp;
  5&nbsp;# 感谢, Sylvain Fourmanoit, 发现了"!"变量的创造性用法.</PRE
></FONT
></TD
></TR
></TABLE
>

            </P
></DD
><DT
><A
NAME="UNDERSCOREREF"
></A
><CODE
CLASS="VARNAME"
>$_</CODE
></DT
><DD
><P
>这个变量保存之前执行的命令的最后一个参数的值. </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="USCREF"
></A
><P
><B
>例子 9-9. 下划线变量</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>  1&nbsp;#!/bin/bash
  2&nbsp;
  3&nbsp;echo $_              # /bin/bash
  4&nbsp;                     # 只是调用/bin/bash来运行这个脚本.
  5&nbsp;
  6&nbsp;du &#62;/dev/null        # 这么做命令行上将没有输出.
  7&nbsp;echo $_              # du
  8&nbsp;
  9&nbsp;ls -al &#62;/dev/null    # 这么做命令行上将没有输出.
 10&nbsp;echo $_              # -al  (这是最后的参数)
 11&nbsp;
 12&nbsp;:
 13&nbsp;echo $_              # :</PRE
></FONT
></TD
></TR
></TABLE
><HR></DIV
></DD
><DT
><A
NAME="XSTATVARREF"
></A
><CODE
CLASS="VARNAME"
>$?</CODE
></DT
><DD
><P
>命令, <A
HREF="functions.html#FUNCTIONREF"
>函数</A
>,
	    或者是脚本本身的(参见<A
HREF="complexfunct.html#MAX"
>例子 23-7</A
>)<A
HREF="exit-status.html#EXITSTATUSREF"
>退出状态码</A
></P
></DD
><DT
><A
NAME="PROCCID"
></A
><CODE
CLASS="VARNAME"
>$$</CODE
></DT
><DD
><P
>脚本自身的进程ID. 
			  <CODE
CLASS="VARNAME"
>$$</CODE
>变量在脚本中经常用来构造<SPAN
CLASS="QUOTE"
>"唯一的"</SPAN
>临时文件名(参见<A
HREF="contributed-scripts.html#FTPGET"
>例子 A-13</A
>, 
				  <A
HREF="debugging.html#ONLINE"
>例子 29-6</A
>, <A
HREF="filearchiv.html#DERPM"
>例子 12-28</A
>, 和<A
HREF="x6756.html#SELFDESTRUCT"
>例子 11-26</A
>). 这么做通常比调用<A
HREF="filearchiv.html#MKTEMPREF"
>mktemp</A
>命令来的简单.</P
></DD
></DL
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>注意事项</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN4091"
HREF="internalvariables.html#AEN4091"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>当然, 当前运行脚本的PID就是<CODE
CLASS="VARNAME"
>$$</CODE
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN4390"
HREF="internalvariables.html#AEN4390"
><SPAN
CLASS="footnote"
>[2]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>术语<SPAN
CLASS="QUOTE"
>"argument"</SPAN
>和<SPAN
CLASS="QUOTE"
>"parameter"</SPAN
>通常情况下都可以互换使用. 
				在本书的上下文中, 它们的意思完全相同, 意思都是传递给脚本或者函数的变量, 或者是位置参数. 
		(译者注: 翻译时, 基本上就未加区分.)</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="variables2.html"
ACCESSKEY="P"
>前一页</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>首页</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="string-manipulation.html"
ACCESSKEY="N"
>下一页</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>变量重游</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="variables2.html"
ACCESSKEY="U"
>上一级</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>操作字符串</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>